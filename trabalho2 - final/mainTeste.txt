#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <memory>
#include <utility>
#include <chrono>
#include <iomanip>
#include <map>
#include <numeric>
#include <limits>
#include <algorithm> // Necessário para std::min_element

#include "Grafo.h"
#include "AlgoritmosGulosos.h"

// Estrutura para guardar os resultados processados
struct ResultadoProcessado {
    std::vector<char> melhor_solucao_encontrada; // Guarda o conjunto de vértices
    double valor_comparacao = 0.0; // Guarda o melhor valor (não a média)
    double media_tempo_ms = 0.0;
    double desvio_percentual = 0.0;
};

// Função auxiliar para carregar um grafo
std::unique_ptr<Grafo> carregarGrafo(const std::string& nome_arquivo) {
    std::ifstream arquivo(nome_arquivo);
    if (!arquivo) {
        std::cerr << "ERRO: Não foi possível abrir o arquivo de instância: " << nome_arquivo << std::endl;
        return nullptr;
    }
    std::string linha;
    std::getline(arquivo, linha);
    std::stringstream ss_flags(linha);
    int flag1, flag2, flag3; ss_flags >> flag1 >> flag2 >> flag3;
    bool direcionado = (flag1 == 1), ponderado_aresta = (flag2 == 1), ponderado_vertice = (flag3 == 1);
    int ordem = 0; arquivo >> ordem;
    std::vector<char> ids_vertices; char id_vertice;
    for (int i = 0; i < ordem; ++i) { if (arquivo >> id_vertice) ids_vertices.push_back(id_vertice); }
    std::vector<std::pair<char, char>> arestas_pares; char origem, destino;
    while (arquivo >> origem >> destino) { arestas_pares.push_back({origem, destino}); }
    return std::make_unique<Grafo>(direcionado, ponderado_aresta, ponderado_vertice, ids_vertices, arestas_pares);
}

// Função auxiliar para imprimir um vetor de char
void imprimirVetor(std::ostream& os, const std::vector<char>& vec) {
    os << "{";
    for (size_t i = 0; i < vec.size(); ++i) {
        os << vec[i] << (i == vec.size() - 1 ? "" : ",");
    }
    os << "}";
}

int main() {
    // --- PARÂMETROS DE CONFIGURAÇÃO DO EXPERIMENTO ---
    std::vector<std::string> instancias = {
        "g_10_0.30_0_0_2.txt", "g_10_0.50_0_0_1.txt", "g_10_0.60_0_0_0.txt",
        "g_25_0.21_0_1_1.txt", "g_25_0.28_0_0_1.txt", "g_25_0.48_1_0_1.txt",
        "g_40_0.20_0_1_0.txt", "g_50_0.44_1_0_0.txt", "g_60_0.07_0_1_0.txt",
        "g_60_0.17_0_1_0.txt"
    };

    std::vector<float> alfas = {0.2, 0.5, 0.8};
    int num_execucoes = 10;
    int iteracoes_randomizado = 30;
    int iteracoes_reativo = 300;

    std::cout << "Iniciando experimentos... Isso pode levar algum tempo." << std::endl;

    std::map<std::string, std::map<std::string, ResultadoProcessado>> resultados;
    std::map<std::string, double> somas_valores;
    std::map<std::string, double> somas_tempos;
    std::map<std::string, double> somas_desvios;


    for (const std::string& nome_instancia : instancias) {
        std::unique_ptr<Grafo> grafo = carregarGrafo(nome_instancia);
        if (!grafo) continue;

        std::cout << "Processando instancia: " << nome_instancia << "..." << std::endl;
        double best_valor_instancia = std::numeric_limits<double>::max();
        
        // --- Experimento 1: Guloso ---
        auto inicio = std::chrono::high_resolution_clock::now();
        std::vector<char> solucao_guloso = AlgoritmosGulosos::algoritmoGuloso(grafo.get());
        auto fim = std::chrono::high_resolution_clock::now();
        resultados[nome_instancia]["Guloso"].melhor_solucao_encontrada = solucao_guloso;
        resultados[nome_instancia]["Guloso"].valor_comparacao = solucao_guloso.size();
        resultados[nome_instancia]["Guloso"].media_tempo_ms = std::chrono::duration_cast<std::chrono::milliseconds>(fim - inicio).count();
        if (solucao_guloso.size() > 0 && solucao_guloso.size() < best_valor_instancia) best_valor_instancia = solucao_guloso.size();

        // --- Experimento 2: Randomizado ---
        for (float alfa : alfas) {
            std::vector<char> melhor_solucao_local;
            std::vector<double> tempos_temp;
            for (int i = 0; i < num_execucoes; ++i) {
                inicio = std::chrono::high_resolution_clock::now();
                std::vector<char> solucao_rand = AlgoritmosGulosos::algoritmoGulosoRandomizado(grafo.get(), alfa, iteracoes_randomizado);
                fim = std::chrono::high_resolution_clock::now();
                tempos_temp.push_back(std::chrono::duration_cast<std::chrono::milliseconds>(fim - inicio).count());
                if (melhor_solucao_local.empty() || solucao_rand.size() < melhor_solucao_local.size()){
                    melhor_solucao_local = solucao_rand;
                }
            }
            if (melhor_solucao_local.size() > 0 && melhor_solucao_local.size() < best_valor_instancia) best_valor_instancia = melhor_solucao_local.size();
            std::string nome_alg = "Rand_" + std::to_string(alfa).substr(0,3);
            resultados[nome_instancia][nome_alg].melhor_solucao_encontrada = melhor_solucao_local;
            resultados[nome_instancia][nome_alg].valor_comparacao = melhor_solucao_local.size();
            resultados[nome_instancia][nome_alg].media_tempo_ms = std::accumulate(tempos_temp.begin(), tempos_temp.end(), 0.0) / num_execucoes;
        }

        // --- Experimento 3: Reativo ---
        std::vector<char> melhor_solucao_local_reativo;
        std::vector<double> tempos_temp_reativo;
        for (int i = 0; i < num_execucoes; ++i) {
            inicio = std::chrono::high_resolution_clock::now();
            std::vector<char> solucao_reativo = AlgoritmosGulosos::algoritmoGulosoRandomizadoReativo(grafo.get(), iteracoes_reativo);
            fim = std::chrono::high_resolution_clock::now();
            tempos_temp_reativo.push_back(std::chrono::duration_cast<std::chrono::milliseconds>(fim - inicio).count());
            if(melhor_solucao_local_reativo.empty() || solucao_reativo.size() < melhor_solucao_local_reativo.size()){
                melhor_solucao_local_reativo = solucao_reativo;
            }
        }
        if (melhor_solucao_local_reativo.size() > 0 && melhor_solucao_local_reativo.size() < best_valor_instancia) best_valor_instancia = melhor_solucao_local_reativo.size();
        resultados[nome_instancia]["Reativo"].melhor_solucao_encontrada = melhor_solucao_local_reativo;
        resultados[nome_instancia]["Reativo"].valor_comparacao = melhor_solucao_local_reativo.size();
        resultados[nome_instancia]["Reativo"].media_tempo_ms = std::accumulate(tempos_temp_reativo.begin(), tempos_temp_reativo.end(), 0.0) / num_execucoes;

        // --- Pós-processamento e Acumulação para Médias ---
        resultados[nome_instancia]["Best"].valor_comparacao = best_valor_instancia;
        for (auto& par : resultados[nome_instancia]) {
            const std::string& nome_alg = par.first;
            if(nome_alg != "Best"){
                par.second.desvio_percentual = (par.second.valor_comparacao - best_valor_instancia) / best_valor_instancia;
                somas_valores[nome_alg] += par.second.valor_comparacao;
                somas_tempos[nome_alg] += par.second.media_tempo_ms;
                somas_desvios[nome_alg] += par.second.desvio_percentual;
            }
        }
    }
    
    // --- GERAÇÃO DO ARQUIVO DE SAÍDA ---
    std::ofstream arquivo_saida("resultados.txt");
    arquivo_saida << std::fixed << std::setprecision(2);
    size_t num_instancias = instancias.size();

    // Tabela 1: Melhor Valor Encontrado (Tamanho da Solução)
    arquivo_saida << "--- TABELA DE MELHOR VALOR ENCONTRADO (TAMANHO DA SOLUCAO) ---\n\n";
    arquivo_saida << std::left << std::setw(25) << "Instancia" << std::setw(10) << "Guloso";
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << ("R_" + std::to_string(alfa).substr(0,3)); }
    arquivo_saida << std::setw(8) << "Reativo" << "\n";
    arquivo_saida << std::string(35 + 8 * alfas.size(), '-') << "\n";
    for(const auto& par_inst : resultados){
        arquivo_saida << std::left << std::setw(25) << par_inst.first;
        arquivo_saida << std::setw(10) << (int)par_inst.second.at("Guloso").valor_comparacao;
        for(float alfa : alfas) {
             arquivo_saida << std::setw(8) << (int)par_inst.second.at("Rand_" + std::to_string(alfa).substr(0,3)).valor_comparacao;
        }
        arquivo_saida << std::setw(8) << (int)par_inst.second.at("Reativo").valor_comparacao << "\n";
    }
    arquivo_saida << std::string(35 + 8 * alfas.size(), '-') << "\n";
    arquivo_saida << std::left << std::setw(25) << "Media";
    arquivo_saida << std::setw(10) << somas_valores["Guloso"] / num_instancias;
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << somas_valores["Rand_" + std::to_string(alfa).substr(0,3)] / num_instancias; }
    arquivo_saida << std::setw(8) << somas_valores["Reativo"] / num_instancias << "\n";


    // Tabela 2: Qualidade (Desvio Percentual)
    arquivo_saida << "\n\n--- TABELA DE QUALIDADE (DESVIO PERCENTUAL) ---\n\n";
    arquivo_saida << std::left << std::setw(25) << "Instancia" << std::setw(8) << "Best" << std::setw(10) << "Guloso";
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << ("R_" + std::to_string(alfa).substr(0,3)); }
    arquivo_saida << std::setw(8) << "Reativo" << "\n";
    arquivo_saida << std::string(43 + 8 * alfas.size(), '-') << "\n";
    for(const auto& par_inst : resultados){
        arquivo_saida << std::left << std::setw(25) << par_inst.first
                      << std::setw(8) << (int)par_inst.second.at("Best").valor_comparacao
                      << std::setw(10) << par_inst.second.at("Guloso").desvio_percentual;
        for(float alfa : alfas) {
             arquivo_saida << std::setw(8) << par_inst.second.at("Rand_" + std::to_string(alfa).substr(0,3)).desvio_percentual;
        }
        arquivo_saida << std::setw(8) << par_inst.second.at("Reativo").desvio_percentual << "\n";
    }
    arquivo_saida << std::string(43 + 8 * alfas.size(), '-') << "\n";
    arquivo_saida << std::left << std::setw(25) << "Media Desvio" << std::setw(8) << "-";
    arquivo_saida << std::setw(10) << somas_desvios["Guloso"] / num_instancias;
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << somas_desvios["Rand_" + std::to_string(alfa).substr(0,3)] / num_instancias; }
    arquivo_saida << std::setw(8) << somas_desvios["Reativo"] / num_instancias << "\n";


    // Tabela 3: Tempo (Média em ms)
    arquivo_saida << "\n\n--- TABELA DE TEMPO (MEDIA EM MILISSEGUNDOS) ---\n\n";
    arquivo_saida << std::left << std::setw(25) << "Instancia" << std::setw(10) << "Guloso";
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << ("R_" + std::to_string(alfa).substr(0,3)); }
    arquivo_saida << std::setw(8) << "Reativo" << "\n";
    arquivo_saida << std::string(35 + 8 * alfas.size(), '-') << "\n";
    for(const auto& par_inst : resultados){
        arquivo_saida << std::left << std::setw(25) << par_inst.first
                      << std::setw(10) << par_inst.second.at("Guloso").media_tempo_ms;
        for(float alfa : alfas) {
             arquivo_saida << std::setw(8) << par_inst.second.at("Rand_" + std::to_string(alfa).substr(0,3)).media_tempo_ms;
        }
        arquivo_saida << std::setw(8) << par_inst.second.at("Reativo").media_tempo_ms << "\n";
    }
    arquivo_saida << std::string(35 + 8 * alfas.size(), '-') << "\n";
    arquivo_saida << std::left << std::setw(25) << "Media Tempo";
    arquivo_saida << std::setw(10) << somas_tempos["Guloso"] / num_instancias;
    for(float alfa : alfas) { arquivo_saida << std::setw(8) << somas_tempos["Rand_" + std::to_string(alfa).substr(0,3)] / num_instancias; }
    arquivo_saida << std::setw(8) << somas_tempos["Reativo"] / num_instancias << "\n";
    

    // Tabela 4: Melhores Soluções Encontradas (Conjunto de Vértices)
    arquivo_saida << "\n\n--- TABELA DE MELHORES SOLUCOES (CONJUNTO DE VERTICES) ---\n\n";
    arquivo_saida << std::left << std::setw(25) << "Instancia" << std::setw(15) << "Algoritmo" << std::setw(10) << "Tamanho" << "Solucao\n";
    arquivo_saida << std::string(90, '-') << "\n";

    for(const auto& par_inst : resultados){
        // Guloso
        arquivo_saida << std::left << std::setw(25) << par_inst.first << std::setw(15) << "Guloso" << std::setw(10) << (int)par_inst.second.at("Guloso").valor_comparacao;
        imprimirVetor(arquivo_saida, par_inst.second.at("Guloso").melhor_solucao_encontrada);
        arquivo_saida << "\n";
        
        // Randomizados
        for(float alfa : alfas){
            std::string nome_alg = "Rand_" + std::to_string(alfa).substr(0,3);
            arquivo_saida << std::left << std::setw(25) << "" << std::setw(15) << nome_alg << std::setw(10) << (int)par_inst.second.at(nome_alg).valor_comparacao;
            imprimirVetor(arquivo_saida, par_inst.second.at(nome_alg).melhor_solucao_encontrada);
            arquivo_saida << "\n";
        }

        // Reativo
        arquivo_saida << std::left << std::setw(25) << "" << std::setw(15) << "Reativo" << std::setw(10) << (int)par_inst.second.at("Reativo").valor_comparacao;
        imprimirVetor(arquivo_saida, par_inst.second.at("Reativo").melhor_solucao_encontrada);
        arquivo_saida << "\n";

        arquivo_saida << std::string(90, '-') << "\n";
    }

    arquivo_saida.close();
    std::cout << "\nExperimentos concluidos! Resultados salvos em 'resultados.txt'." << std::endl;

    return 0;
}